:PROPERTIES:
:ID:       9781c339-1729-43eb-97b4-e2ff2bbe44a2
:END:
#+title: rust cp
* kattis - thelastproblem
#+begin_src rust
fn solution(s: &str) -> String {
    format!("Thank you, {}, and farewell!", s)
}

fn main() {
    let v = "Cinderilla";
    println!("{}", solution(v));
}
#+end_src

#+RESULTS:
: Thank you, Cinderilla, and farewell!

* kattis - filip
#+begin_src rust
fn solution(s: &str) -> u32 {
    s.split_whitespace()
     .map(|s| s.chars()
               .rev()
               .collect::<String>()
               .parse::<u32>()
               .unwrap())
     .max()
     .unwrap()
}

fn main() {
    let v = "115 123";
    println!("{}", solution(v));
}
#+end_src

#+RESULTS:
: 511
* kattis - onechicken
#+begin_src rust :crates '((itertools . "0.10.3"))
use itertools::Itertools;

fn solution(s: &str) -> String {
    let (x, y) = s.splitn(2, " ").collect_tuple().unwrap();
    match x > y {
        true => format!("Dr. Chaz will have {} pieces of chicken left over!", x - y),
        false => format!("aDr. Chaz needs {} more pieces of chicken!", y - x)
    }
}
// fn solution(s: &str) -> string {
//     let v = s.split_whitespace()
//              .map(|s| s.parse::<u32>().unwrap())
//              .collect::<vec<u32>>();
//     match v[0] > v[1] {
//         true => format!("dr. chaz will have {} pieces of chicken left over!", v[0] - v[1]),
//         false => format!("dr. chaz needs {} more pieces of chicken!", v[1] - v[0])
//     }
// }

fn main() {
    let v = "20 100";
    println!("{}", solution(v));
    let v = "2 3";
    println!("{}", solution(v));
    let v = "10 1";
    println!("{}", solution(v));
}
#+end_src

#+RESULTS:
: error: Could not compile `cargoMo2cxE`.

* kattis - lineup
#+BEGIN_SRC rust :toolchain 'nightly
#![feature(is_sorted)]

fn solution(s: Vec<&str>) -> String {
    if s[1..].is_sorted() {
        "ASCENDING".to_string()
    } else if s[1..].is_sorted_by(|a, b| b.partial_cmp(a)) {
        "DESCENDING".to_string()
    } else {
        "NEITHER".to_string()
    }
}

fn main() {
    let in1 = vec![
        "5",
        "JOE",
        "BOB",
        "ANDY",
        "AL",
        "ADAM",
    ];
    let in2 = vec![
        "11",
        "HOPE",
        "ALI",
        "BECKY",
        "JULIE",
        "MEGHAN",
        "LAUREN",
        "MORGAN",
        "CARLI",
        "MEGAN",
        "ALEX",
        "TOBIN",
    ];
    let in3 = vec![
        "4",
        "GEORGE",
        "JOHN",
        "PAUL",
        "RINGO",
    ];
    println!("{:?}", solution(in1));
    println!("{:?}", solution(in2));
    println!("{:?}", solution(in3));
}
#+END_SRC

#+RESULTS:
: "DESCENDING"
: "NEITHER"
: "ASCENDING"
* kattis - pokerhand
#+begin_src rust
use std::collections::HashMap;
use std::hash::Hash;

fn solution(s: String) -> u8 {
    let ranks = s.split_whitespace()
                 .map(|x| x.chars().nth(0).unwrap())
                 .collect::<Vec<char>>();
    let count_rank = counter(ranks.iter());
    let max_rank = count_rank.iter()
                             .max_by_key(|a| a.1)
                             .map(|(_,v)| v)
                             .unwrap();
    *max_rank
}


fn counter<K: Eq + Hash, I: Iterator<Item=K>>(iterable: I) -> HashMap<K, u8> {
    let mut map = HashMap::new();
    for element in iterable {
        *map.entry(element).or_insert(0) += 1;
    }
    map
}

fn main() {
    let in1 = "AC AD AH AS KD".to_string();
    let in2 = "2C 4D 4H 2D 2H".to_string();
    let in3 = "AH 2H 3H 4H 5H".to_string();
    let out1 = 4;
    let out2 = 3;
    let out3 = 1;
    assert_eq!(solution(in1), out1);
    assert_eq!(solution(in2), out2);
    assert_eq!(solution(in3), out3);
    println!("{:?}", solution("AC AD AH AS KD".to_string()));
}
#+end_src

#+RESULTS:
: 4
* kattis - sevenwonders
#+begin_src rust
use std::collections::HashMap;
use std::hash::Hash;

fn counter<K: Eq + Hash, I: Iterator<Item=K>>(iterable: I) -> HashMap<K, u32> {
    let mut map = HashMap::new();
    for e in iterable {
        ,*map.entry(e).or_insert(0) += 1;
    }
    map
}

fn solution(s: String) -> u32 {
    let mut score = 0;
    let cards = s.chars();
    let count = counter(cards);
    for (_k,v) in &count {
        score += v.pow(2);
    }
    if &count.len() == &3 {
        let mul = count.iter()
                       .min_by_key(|a| a.1)
                       .map(|(_,v)| v)
                       .unwrap();
        score += 7 * mul;
    }
    score
}

fn main() {
    println!("{:?}", solution("TCGTTC".to_string()));
    let in1 = "TCGTTC".to_string();
    let in2 = "CCC".to_string();
    let in3 = "TTCCGG".to_string();
    let out1 = 21;
    let out2 = 9;
    let out3 = 26;
    assert_eq!(solution(in1), out1);
    assert_eq!(solution(in2), out2);
    assert_eq!(solution(in3), out3);
}
#+end_src

#+RESULTS:
: 21
* kattis - vote
#+begin_src rust
fn solution(mut s: Vec<usize>) -> Vec<String> {
    (0..s[0]).map(|i| {
        let voting_session = s.drain(i+2..i+2+s[1+i]).collect::<Vec<usize>>();
        let (winner_idx, winner_score) = &voting_session.iter().enumerate().max_by_key(|x| x.1).unwrap();
        if voting_session.iter().filter(|x| x == winner_score).count() > 1 {
            format!("no winner")
        } else if *winner_score > &(voting_session.iter().sum::<usize>() - *winner_score)  {
            format!("majority winner {}", winner_idx + 1)
        } else {
            format!("minority winner {}", winner_idx + 1)
        }
    }).collect::<Vec<String>>()
}

fn main() {
    let i = vec![
        5,
        3,
        10,
        21,
        10,
        3,
        20,
        10,
        10,
        3,
        20,
        20,
        10,
        3,
        10,
        10,
        10,
        4,
        15,
        15,
        15,
        45,
    ];
    let o = vec![
        "majority winner 2",
        "minority winner 1",
        "no winner",
        "no winner",
        "minority winner 4",
    ];
    assert_eq!(solution(i), o);
}
#+end_src

#+RESULTS:

* kattis - artichoke
#+begin_src rust :crates
fn formula(p: u32, a: u32, b: u32, c: u32, d: u32, k: u32) -> f64 {
    (p as f64) * (((a*k+b) as f64).sin()+((c*k+d) as f64).cos()+2.0)
}

trait PreciseRound<T> {
    fn round_with_precision(self, p: u8) -> T;
}

impl PreciseRound<f64> for f64 {
    fn round_with_precision(self, p: u8) -> f64 {
        let precision = 10_f64.powf(p as f64);
        (self * precision).round() / precision
    }
}

fn solution(s: String) -> f64 {
    let vars: Vec<u32> = s.split_whitespace()
                          .map(|s| s.parse().unwrap())
                          .collect();
    let (mut diff, mut vmax): (f64, f64) = (0., f64::MIN);
    if let [p,a,b,c,d,n] = vars[0..6] {
        let prices: Vec<f64> = (1..(n as u32)+1).map(|k| formula(p,a,b,c,d,k.into())).collect();
        for p in prices {
            // https://math.stackexchange.com/questions/1172115
            (diff, vmax) = (diff.max(vmax - p), vmax.max(p));
        }
    }
    diff.round_with_precision(6)
}
fn main() {
    let i1 = "42 1 23 4 8 10".to_string();
    let i2 = "100 7 615 998 801 3".to_string();
    let i3 = "100 432 406 867 60 1000".to_string();
    let o1 = 104.85511;
    let o2 = 0.00;
    let o3 = 399.303813;
    assert_eq!(solution(i1), o1);
    assert_eq!(solution(i2), o2);
    assert_eq!(solution(i3), o3);
}
#+end_src

#+RESULTS:

* kattis - basicprogramming1
** 1
#+begin_src rust :tangle ~/Desktop/trash/basicprogramming1.rs
#![allow(unused_variables, dead_code)]

trait Solver {
    fn solve(&self, input: &Input) -> String;
}

#[derive(Clone)]
struct Input {
    n: u32,
    t: u32,
    a: Vec<u32>
}

impl Input {
    fn parse(s: String) -> Self {
        let dawaj = s.split_whitespace()
                           .map(|s| s.chars()
                                .collect::<String>()
                                .parse::<u32>()
                                .unwrap()).collect::<Vec<u32>>();


        match dawaj.as_slice() {
            [n, t, array @ ..] => Input {
                n: *n,
                t: *t,
                a: array.to_vec()
            },
            _ => panic!()
        }
    }
    fn select_solver(&self) -> impl Solver {
        match self.t {
            1 => {return <Option1 as Solver>::solve;},
            2 => {return <Option2 as Solver>::solve;},
            _ => panic!()
            // 3 => Option3,
            // 4 => Option4,
            // 5 => Option5,
            // 6 => Option6,
            // 7 => Option7,
        }
    }
}

struct Option1;
struct Option2;
struct Option3;
struct Option4;
struct Option5;
struct Option6;
struct Option7;
impl Solver for Option1 {
    fn solve(&self, input: &Input) -> String {
        "s".to_string()
    }
}
impl Solver for Option2 {
    fn solve(&self, input: &Input) -> String {
        "s".to_string()
    }
}
impl Solver for Option3 {
    fn solve(&self, input: &Input) -> String {
        "s".to_string()
    }
}
impl Solver for Option4 {
    fn solve(&self, input: &Input) -> String {
        "s".to_string()
    }
}
impl Solver for Option5 {
    fn solve(&self, input: &Input) -> String {
        "s".to_string()
    }
}
impl Solver for Option6 {
    fn solve(&self, input: &Input) -> String {
        "s".to_string()
    }
}
impl Solver for Option7 {
    fn solve(&self, input: &Input) -> String {
        "s".to_string()
    }
}

fn solution(s: &str) -> String {
    let parsed: Input = Input::parse(s.to_string());
    let s = &parsed.select_solver();
    s.solve(&parsed.clone());
    "s".to_string()
}

fn main() {
    let input = "7 1 1 2 3 4 5 6 7";
    // let output = "7";
    println!("{}", solution(input));
    // let input = "7 2 1 2 3 4 5 6 7";
    // let output = "Smaller";
    // let input = "7 3 1 2 3 4 5 6 7";
    // let output = "2";
    // let input = "7 4 1 2 3 4 5 6 7";
    // let output = "28";
    // let input = "7 5 1 2 3 4 5 6 7";
    // let output = "12";
    // let input = "10 6 7 4 11 37 14 22 40 17 11 3";
    // let output = "helloworld";
    // let input = "3 7 1 0 2";
    // let output = "Cyclic";
}
#+end_src

#+RESULTS:
: error: Could not compile `cargo9An818`.

** 2
#+begin_src rust :tangle ~/Desktop/trash/basicprogramming1.rs
#![allow(unused_variables, dead_code)]

trait Parser {
    fn parse(s: String) -> Self;
}

#[derive(Clone)]
struct Input {
    n: u32,
    t: u32,
    a: Vec<u32>
}

impl Parser for Input {
    fn parse(s: String) -> Self {
        match s.split_whitespace()
                           .map(|s| s.chars()
                                .collect::<String>()
                                .parse::<u32>()
                                .unwrap()).collect::<Vec<u32>>().as_slice() {
            [n, t, array @ ..] => Self {
                n: *n,
                t: *t,
                a: array.to_vec()
            },
            _ => panic!()
        }
    }
}

struct Solver;
impl Solver {
    fn solve(i: Input) -> String {
        match i.t {
            1 => Self::case1(i.a),
            2 => Self::case2(i.a),
            3 => Self::case3(i.a),
            4 => Self::case4(i.a),
            5 => Self::case5(i.a),
            6 => Self::case6(i.a),
            7 => Self::case7(i.a),
            _ => panic!()
        }
    }
    fn case1(a: Vec<u32>) -> String { "7".to_string() }
    fn case2(a: Vec<u32>) -> String {
        if let [x,y,..] = a.as_slice() {
            if x > y {
                "Bigger"
            } else if x == y {
                "Equal"
            } else {
                "Smaller"
            }
        } else {
            ""
        }.to_string()
    }
    fn case3(a: Vec<u32>) -> String {
        if let [x,y,z,..] = a.as_slice() {
            let mut v = [x,y,z].to_vec();
            v.sort();
            return v[1].to_string()
        } else {
            return "err".to_string()
        }
    }
    fn case4(a: Vec<u32>) -> String { format!("{}", a.iter().sum::<u32>()) }
    fn case5(a: Vec<u32>) -> String { format!("{}", a.iter().filter(|&x| x % 2 == 0).sum::<u32>()) }
    fn case6(a: Vec<u32>) -> String {
        format!("{}", a.iter()
                       .map(|&x| ('a'..='z').nth((x % 26) as usize).unwrap())
                       .collect::<String>()) }
    fn case7(a: Vec<u32>) -> String {
        let mut i = 0;
        let r = loop {
            if let Some(v) = a.get(i) {
                if *v == a.len() as u32 - 1 {
                    return "Done".to_string();
                } else if a[*v as usize] == i.try_into().unwrap() {
                    return "Cyclic".to_string();
                } else {
                    i = *v as usize;
                }
            } else {
                return "Out".to_string();
            }
        };
    }
}

fn solution(s: &str) -> String {
    let parsed = Input::parse(s.to_string());
    Solver::solve(parsed)
}

fn main() {
    let input = "7 1 1 2 3 4 5 6 7";
    let output = "7";
    println!("{} == {}", solution(input), output);
    let input = "7 2 1 2 3 4 5 6 7";
    let output = "Smaller";
    println!("{} == {}", solution(input), output);
    let input = "7 3 1 2 3 4 5 6 7";
    let output = "2";
    println!("{} == {}", solution(input), output);
    let input = "7 4 1 2 3 4 5 6 7";
    let output = "28";
    println!("{} == {}", solution(input), output);
    let input = "7 5 1 2 3 4 5 6 7";
    let output = "12";
    println!("{} == {}", solution(input), output);
    let input = "10 6 7 4 11 37 14 22 40 17 11 3";
    let output = "helloworld";
    println!("{} == {}", solution(input), output);
    let input = "3 7 1 0 2";
    let output = "Cyclic";
    println!("{} == {}", solution(input), output);
}
#+end_src

#+RESULTS:
: 7 == 7
: Smaller == Smaller
: 2 == 2
: 28 == 28
: 12 == 12
: helloworld == helloworld
: Cyclic == Cyclic

* kattis - treasurehunt
#+begin_src rust
#![allow(unused_variables,dead_code)]

#[derive(Debug)]
struct Mover {
    x: usize,
    y: usize,
    count: u32,
    xb: usize,
    yb: usize
}

impl Mover {
    fn new(bounds: (usize, usize)) -> Self {
        Mover {
            x: 0,
            y: 0,
            count: 0,
            xb: bounds.0,
            yb: bounds.1
        }
    }
    fn travel(&self, direction: char) -> Option<Self> {
        let move_by: (isize, isize) = match direction {
            'E' if self.x + 1 != self.xb => (1, 0),
            'W' if self.x != 0           => (-1,0),
            'N' if self.y != 0           => (0, -1),
            'S' if self.y + 1 != self.yb => (0, 1),
            'E' | 'W' | 'N' | 'S'        => return None,
            _ => panic!()
        };
        Some(Mover {
            x: (move_by.0 + (self.x as isize)) as usize,
            y: (move_by.1 + (self.y as isize)) as usize,
            count: 1 + self.count,
            ..*self
        })
    }
}

fn solution (s: &str) -> String {
    let mut visited: Vec<(usize,usize)> = vec![];
    if let [r, c, rows @ ..] = s.split_whitespace()
                                .into_iter()
                                .collect::<Vec<&str>>()
                                .as_slice() {
        let r: usize = r.parse().unwrap();
        let c: usize = c.parse().unwrap();
        let mut m = Mover::new((r,c));

        loop {
            if let Some(r) = rows.get(m.y) {
                if let Some(c) = r.chars().nth(m.x) {
                    if c == 'T' {
                        return format!("{}", m.count);
                    } else {
                        visited.push((m.x,m.y));
                        if let Some(x) = m.travel(c) {
                            m = x;
                        } else if visited.contains(&(m.x,m.y)) {
                            return "Lost".to_string();
                        } else {
                            return "Out".to_string();
                        }
                    }
                } else {
                    return "Out".to_string() ;
                }
            } else {
                return "Out".to_string();
            }
        }
    }
    return "Out".to_string();
}

fn main() {
    let i = "
    2 2
    ES
    TW";
    let o = 3;
    println!("{} == {}", solution(i), o);
}
#+end_src

#+RESULTS:
: 3 == 3
* kattis - trainpassengers
#+begin_src rust
#![allow(unused_must_use, unused_variables, unused_comparisons)]

#[derive(Copy, Clone, Debug)]
struct Train {
    capacity: u32,
    passengers: u32,
}

struct Parser;

impl Parser {
    fn parse_input(s: &str) -> (u32, u32, Vec<Vec<u32>>, u32) {
        let v = s.lines()
                 .nth(0)
                 .unwrap()
                 .split_whitespace()
                 .into_iter()
                 .map(|c| c.parse::<u32>().unwrap())
                 .collect::<Vec<u32>>();
        let rows = Parser::parse_rows(s);
        let last = rows.last().unwrap().last().unwrap().clone();
        let r = (v[0], v[1], rows, last);
        // dbg!(&r);
        r
    }
    fn parse_rows(s: &str) -> Vec<Vec<u32>> {
        let x = s.lines().collect::<Vec<&str>>();
        let x = &x.as_slice()[1..];
        let x: Vec<_> = x.iter()
                         .map(|s| s.split_whitespace()
                                   .into_iter()
                                   .map(|w| w.parse::<u32>().unwrap()).collect::<Vec<_>>())
                         .collect();
        x
    }
}

impl Train {
    fn new(capacity: u32, passengers: u32) -> Self {
        Train { capacity, passengers }
    }

    fn stop_at_the_station(&mut self, left: u32, entered: u32, stayed: u32) -> Option<bool> {
        // dbg!(&self, left, entered, stayed);
        self.calculate_passengers_onboard(left, entered)
            .and_then(|p| self.check_capacity_coretness(p, stayed))
            .and_then(|p| self.update_passengers_count(p))
    }

    fn calculate_passengers_onboard(&self, left: u32, entered: u32) -> Option<u32> {
        Some(self)
            .and_then(|t| t.passengers.checked_sub(left))
            .and_then(|c| c.checked_add(entered))
    }

    fn update_passengers_count(&mut self, p: u32) -> Option<bool> {
        self.passengers = p;
        Some(true)
    }

    fn check_capacity_coretness(&self, p: u32, stayed: u32) -> Option<u32> {
        if p <= self.capacity && stayed >= 0 && self.capacity >= self.passengers {
            return Some(p);
        }
        None
    }
    fn is_empty(&self) -> bool {
        self.passengers == 0
    }
}

fn solution(s: &str) -> &str {
    let (c, n, rows, last_stayed) = Parser::parse_input(s);
    if last_stayed > 0 { return "impossible"; }
    let mut t = Train::new(c, 0);
    for row in rows {
        if let [left, entered, stayed] = row.as_slice() {
            if t.stop_at_the_station(*left, *entered, *stayed).is_none() {
                // dbg!(&t);
                return "impossible";
            }
        }
    }
    if t.is_empty() {
        "possible"
    } else {
        "impossible"
    }
}

fn main() {

    let i = "1 2
    0 1 1
    1 0 0";
    let o = "possible";
    println!("{} == {}", solution(i), o);
    let i = "1 2
    1 0 0
    0 1 0";
    let o = "impossible";
    println!("{} == {}", solution(i), o);
    let i = "1 2
    0 1 0
    1 0 1";
    let o = "impossible";
    println!("{} == {}", solution(i), o);
    let i = "1 2
    0 1 1
    0 0 0";
    let o = "impossible";
    println!("{} == {}", solution(i), o);
}
#+end_src

#+RESULTS:
#+begin_example
[src/main.rs:24] &r = (
    1,
    2,
    [
        [
            0,
            1,
            1,
        ],
        [
            1,
            0,
            0,
        ],
    ],
    0,
)
possible == possible
[src/main.rs:24] &r = (
    1,
    2,
    [
        [
            1,
            0,
            0,
        ],
        [
            0,
            1,
            0,
        ],
    ],
    0,
)
impossible == impossible
[src/main.rs:24] &r = (
    1,
    2,
    [
        [
            0,
            1,
            0,
        ],
        [
            1,
            0,
            1,
        ],
    ],
    1,
)
impossible == impossible
[src/main.rs:24] &r = (
    1,
    2,
    [
        [
            0,
            1,
            1,
        ],
        [
            0,
            0,
            0,
        ],
    ],
    0,
)
impossible == impossible
#+end_example

* kattis - friday
- every year starts on a Sunday
#+begin_src rust
fn solution(i: &str) -> String {
    i.lines()
        .skip(2)
        .step_by(2)
        .map(|year| {
            year.split_whitespace()
                .map(|v| v.parse().unwrap())
                .collect()
        })
        .map(|months: Vec<u32>| {
            let mut month_starts_at = 0;
            let mut happy_days_count = 0;
            for days_in_month in months {
                if month_starts_at == 0 && days_in_month >= 13 {
                    happy_days_count += 1;
                }
                month_starts_at = days_in_month % 7;
            }
            happy_days_count.to_string()
        })
        .collect::<Vec<_>>()
        .join("\n")
}

fn main() {
    let i = "3
20 1
20
40 2
21 19
365 12
31 28 31 30 31 30 31 31 30 31 30 31";
    let o = "1
2
2";
    assert_eq!(solution(i), o);
}
#+end_src
* kattis - skener
#+begin_src rust
fn solution(i: &str) -> String {
    if let [_, _, zr, zc, data @ ..] = i.split_whitespace().collect::<Vec<&str>>().as_slice() {
        let zr: usize = zr.parse().unwrap();
        let zc: usize = zc.parse().unwrap();
        let mut out: Vec<String> = vec![];
        for d in data {
            let mut r = String::new();
            for c in d.chars() {
                r.push_str(std::iter::repeat(c).take(zc).collect::<String>().as_str());
            }
            for _ in 0..zr {
                out.push(r.clone());
            }
        }
        return out.join("\n");
    }
    "".to_string()
}

fn main() {
    let i = "3 3 1 2
.x.
x.x
.x.";
    let o = "..xx..
xx..xx
..xx..
";
    println!("{} == {}", solution(i), o);
    let i = "3 3 2 1
.x.
x.x
.x.";
    let o = ".x.
.x.
x.x
x.x
.x.
.x.
";
    println!("{} == {}", solution(i), o);
}
#+end_src
* kattis - chopin
#+begin_src rust
use std::collections::HashMap;

fn find_value(v: &str, d: &HashMap<&str, &str>) -> Option<String> {
    if let Some((a, b)) = std::iter::zip(d.values(), d.keys()).find(|(x, y)| *x == &v || *y == &v) {
        if &v == a {
            Some(b.to_string())
        } else {
            Some(a.to_string())
        }
    } else {
        None
    }
}

fn solution(i: &str) -> String {
    let mut d = HashMap::new();
    d.insert("A#", "Bb");
    d.insert("C#", "Db");
    d.insert("D#", "Eb");
    d.insert("F#", "Gb");
    d.insert("G#", "Ab");
    i.lines()
        .enumerate()
        .map(|(mut idx, line)| {
            idx += 1;
            let input = line.split_whitespace().collect::<Vec<&str>>();
            let (note, tonality) = (input[0], input[1]);
            if let Some(note) = find_value(note, &d) {
                format!("Case {}: {} {}", idx, note, tonality)
            } else {
                format!("Case {}: UNIQUE", idx)
            }
        })
        .collect::<Vec<String>>()
        .join("\n")
}

fn main() {
    let i = "Ab minor
D# major
G minor";
    let o = "Case 1: G# minor
Case 2: Eb major
Case 3: UNIQUE";
    println!("{} == {}", solution(i), o);
}
#+end_src
* kattis - memory match
#+begin_src rust
use std::collections::{HashMap, HashSet};

fn solution(i: &str) -> String {
    let mut map: HashMap<&str, HashSet<u8>> = HashMap::new();
    let cards = i.lines().nth(0).unwrap().parse::<u8>().unwrap();
    i.lines()
        .skip(2)
        .map(|l| {
            let v = l.split_whitespace().collect::<Vec<&str>>();
            let (c1, p1): (u8, &str) = (v[0].parse().unwrap(), v[2]);
            let (c2, p2): (u8, &str) = (v[1].parse().unwrap(), v[3]);
            map.entry(p1).or_default().insert(c1);
            map.entry(p2).or_default().insert(c2);
            if p1 == p2 {
                map.entry(p2).or_default().insert(0);
            }
        })
        .for_each(drop);
    // dbg!(&map);
    let x = map.values().filter(|v| v.len() == 3).count();
    if map.keys().len() == (cards / 2) as usize {
        return (cards as u8 / 2 - x as u8).to_string();
    } else {
        return map.values().filter(|v| v.len() == 2).count().to_string();
    }
}

fn main() {
    let i = "8
    5
    1 3 earth sun
    2 6 mars sun
    6 3 sun sun
    7 5 earth moon
    2 7 mars earth";
    let o = "3";
    println!("{} == {}", solution(i), o);

    let i = "10
    6
    1 2 moon earth
    9 10 venus sun
    8 7 moon venus
    1 8 moon moon
    4 10 sun sun
    9 6 venus mars";
    let o = "3";
    println!("{} == {}", solution(i), o);

    let i = "8
    2
    1 3 moon earth
    2 6 sun earth";
    let o = "1";
    println!("{} == {}", solution(i), o);
}
#+end_src

#+RESULTS:
: 3 == 3
: 3 == 3
: 1 == 1

* kattis - chess
#+begin_src rust
use std::collections::HashSet;

#[derive(PartialEq, Eq, Hash, Debug)]
struct Field {
    x: u8,
    y: u8,
}
impl Field {
    fn parse(x: &str, y: &str) -> Self {
        Field {
            x: ('A'..='H')
                .position(|l| l.to_string() == x.to_string())
                .unwrap() as u8
                + 1,
            y: y.parse().unwrap(),
        }
    }
    fn color(&self) -> String {
        if (self.x + self.y) % 2 == 0 {
            "black".to_string()
        } else {
            "white".to_string()
        }
    }
    fn to_string(&self) -> String {
        format!(
            "{} {}",
            ('A'..='H').nth(self.x as usize - 1).unwrap(),
            self.y
        )
    }
    fn get_diagonal_fields(&self) -> HashSet<Field> {
        let mut h: HashSet<Field> = HashSet::new();
        let d: Vec<(i8, i8)> = vec![(1, 1), (-1, 1), (1, -1), (-1, -1)];
        for (dx, dy) in d {
            let (mut x, mut y) = (self.x, self.y);
            while (1..=8).contains(&x) && (1..=8).contains(&y) {
                h.insert(Field { x, y });
                x = (x as i8 + 1 * dx) as u8;
                y = (y as i8 + 1 * dy) as u8;
            }
        }
        h
    }
}

fn solution(i: &str) -> String {
    i.lines()
        .skip(1)
        .map(|s| {
            let v = s.split_whitespace().collect::<Vec<&str>>();
            let (start, end) = (Field::parse(v[0], v[1]), Field::parse(v[2], v[3]));
            if start.color() != end.color() {
                return "Impossible".to_string();
            } else if start.to_string() == end.to_string() {
                return format!("0 {}", start.to_string());
            }
            let s = &start.get_diagonal_fields();
            if s.contains(&end) {
                return format!("1 {} {}", start.to_string(), end.to_string());
            }
            let e = &end.get_diagonal_fields();
            let tada = s.intersection(&e).collect::<Vec<&Field>>();
            return format!(
                "2 {} {} {}",
                start.to_string(),
                tada.first().unwrap().to_string(),
                end.to_string()
            );
        })
        .collect::<Vec<String>>()
        .join("\n")
}

fn main() {
    let i = "3
E 2 E 3
F 1 E 8
A 3 A 3";
    let o = "Impossible
2 F 1 B 5 E 8
0 A 3";
    println!("{} == {}", solution(i), o);
}
#+end_src

#+RESULTS:
: Impossible
: 2 F 1 B 5 E 8
: 0 A 3 == Impossible
: 2 F 1 B 5 E 8
: 0 A 3
* kattis - helpme
#+begin_src rust
use std::cmp::Ordering;

fn solution(input: &str) -> String {
    let mut whites = vec![];
    let mut blacks = vec![];

    input
        .lines()
        .rev()
        .skip(1)
        .step_by(2)
        .enumerate()
        .for_each(|(idx, l)| {
            l.trim_matches('|')
                .split('|')
                .enumerate()
                .for_each(|(idy, y)| {
                    let f = y.chars().nth(1).unwrap();
                    if f.is_alphabetic() {
                        if f.is_uppercase() {
                            whites.push(format!(
                                "{}{}{}",
                                f,
                                ('a'..='h').nth(idy).unwrap(),
                                idx + 1
                            ));
                        } else {
                            blacks.push(format!(
                                "{}{}{}",
                                f.to_uppercase(),
                                ('a'..='h').nth(idy).unwrap(),
                                idx + 1
                            ));
                        }
                    }
                })
        });

    fn sorting_func(color: char) -> impl FnMut(&String, &String) -> Ordering {
        let ord = if color == 'w' {
            (Ordering::Less, Ordering::Greater)
        } else {
            (Ordering::Greater, Ordering::Less)
        };
        return move |a: &String, b: &String| -> Ordering {
            let xa = a.chars().nth(0).unwrap();
            let xb = b.chars().nth(0).unwrap();
            let ya = a.chars().nth(1).unwrap();
            let yb = b.chars().nth(1).unwrap();
            let za: u8 = a.chars().nth(2).unwrap().to_string().parse().unwrap();
            let zb: u8 = b.chars().nth(2).unwrap().to_string().parse().unwrap();

            match (xa, xb) {
                (q, w) if q == w => match (za, zb) {
                    (o, p) if p == o => match (ya, yb) {
                        (s, t) if s > t => Ordering::Greater,
                        _ => Ordering::Less,
                    },
                    (o, p) if p > o => ord.0,
                    _ => ord.1,
                },
                ('K', _) => Ordering::Less,
                ('Q', 'R' | 'B' | 'N' | 'P') => Ordering::Less,
                ('R', 'B' | 'N' | 'P') => Ordering::Less,
                ('B', 'N' | 'P') => Ordering::Less,
                ('N', 'P') => Ordering::Less,
                (_, _) => Ordering::Greater,
            }
        };
    }

    blacks.sort_by(sorting_func('b'));
    whites.sort_by(sorting_func('w'));

    // dbg!(&whites, &blacks);

    return format!("White:{}\nBlack:{}", &whites.join(","), &blacks.join(",")).replace("P", "");
}

fn main() {
    let input = "+---+---+---+---+---+---+---+---+
|.r.|:::|.b.|:q:|.k.|:::|.n.|:r:|
+---+---+---+---+---+---+---+---+
|:p:|.p.|:p:|.p.|:p:|.p.|:::|.p.|
+---+---+---+---+---+---+---+---+
|...|:::|.n.|:::|...|:::|...|:p:|
+---+---+---+---+---+---+---+---+
|:::|...|:::|...|:::|...|:::|...|
+---+---+---+---+---+---+---+---+
|...|:::|...|:::|.P.|:::|...|:::|
+---+---+---+---+---+---+---+---+
|:P:|...|:::|...|:::|...|:::|...|
+---+---+---+---+---+---+---+---+
|.P.|:::|.P.|:P:|...|:P:|.P.|:P:|
+---+---+---+---+---+---+---+---+
|:R:|.N.|:B:|.Q.|:K:|.B.|:::|.R.|
+---+---+---+---+---+---+---+---+";
    let output = "White:Ke1,Qd1,Ra1,Rh1,Bc1,Bf1,Nb1,a2,c2,d2,f2,g2,h2,a3,e4
Black:Ke8,Qd8,Ra8,Rh8,Bc8,Ng8,Nc6,a7,b7,c7,d7,e7,f7,h7,h6";
    println!("{}", dbg!(solution(input)) == output);

    let input = "+---+---+---+---+---+---+---+---+
|...|:::|...|:::|...|:::|...|:::|
+---+---+---+---+---+---+---+---+
|:::|...|:::|...|:::|...|:::|...|
+---+---+---+---+---+---+---+---+
|...|:::|...|:::|...|:::|...|:::|
+---+---+---+---+---+---+---+---+
|:::|...|:::|...|:::|...|:::|.k.|
+---+---+---+---+---+---+---+---+
|...|:::|...|:::|...|:::|...|:::|
+---+---+---+---+---+---+---+---+
|:::|...|:::|...|:::|...|:::|...|
+---+---+---+---+---+---+---+---+
|...|:::|...|:::|...|:::|...|:::|
+---+---+---+---+---+---+---+---+
|:::|...|:::|...|:k:|...|:::|...|
+---+---+---+---+---+---+---+---+";
    let output = "White:
Black:Kh5,Ke1";
    println!("{}", dbg!(solution(input)) == output);
}

#+end_src

#+RESULTS:
: [src/main.rs:101] solution(input) = "White:Ke1,Qd1,Ra1,Rh1,Bc1,Bf1,Nb1,a2,c2,d2,f2,g2,h2,a3,e4\nBlack:Ke8,Qd8,Ra8,Rh8,Bc8,Ng8,Nc6,a7,b7,c7,d7,e7,f7,h7,h6"
: true
: [src/main.rs:122] solution(input) = "White:\nBlack:Kh5,Ke1"
: true

* kattis - empleh
#+begin_src rust
#[derive(Copy, Clone, Debug)]
struct Piece {
    p: char,
    x: u8,
    y: u8,
}

impl Piece {
    fn new(s: &str) -> Self {
        // dbg!(s);
        Piece {
            p: if s.len() > 2 {
                s.chars().nth(0).unwrap()
            } else {
                'P'
            },
            x: ('a'..='h')
                .position(|x| x == s.chars().nth_back(1).unwrap())
                .unwrap() as u8,
            y: s.chars()
                .nth_back(0)
                .unwrap()
                .to_string()
                .parse::<u8>()
                .unwrap()
                - 1,
        }
    }
}

#[derive(Copy, Clone, Debug)]
enum PlayerPiece {
    Black(Piece),
    White(Piece),
}

#[derive(Copy, Clone, Debug)]
struct Field(Option<PlayerPiece>);

impl Field {
    fn get_char(self, default: char) -> char {
        match self.0 {
            Some(PlayerPiece::Black(p)) => p.p.to_lowercase().to_string().chars().nth(0).unwrap(),
            Some(PlayerPiece::White(p)) => p.p,
            _ => default,
        }
    }
}

#[derive(Debug)]
struct Board {
    fields: [[Field; 8]; 8],
}

impl Board {
    fn new() -> Self {
        Board {
            fields: [[Field(None); 8]; 8],
        }
    }
    fn insert(&mut self, piece: PlayerPiece) {
        if let PlayerPiece::Black(p) = piece {
            self.fields[p.y as usize][p.x as usize] = Field(Some(piece));
        }
        if let PlayerPiece::White(p) = piece {
            self.fields[p.y as usize][p.x as usize] = Field(Some(piece));
        }
    }
}

impl std::fmt::Display for Board {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "+---+---+---+---+---+---+---+---+\n{}+---+---+---+---+---+---+---+---+",
            self.fields
                .into_iter()
                .enumerate()
                .map(|(idx, x)| format!(
                    "|{}|\n",
                    x.into_iter()
                        .enumerate()
                        .map(|(idy, y)| {
                            let c = if (idx + idy) % 2 == 0 { ':' } else { '.' };
                            format!("{}{}{}", c, y.get_char(c), c)
                        })
                        .collect::<Vec<String>>()
                        .join("|")
                ))
                .rev()
                .collect::<Vec<String>>()
                .join("+---+---+---+---+---+---+---+---+\n")
        )
    }
}

fn solution(input: &str) -> String {
    let mut board = Board::new();

    input.lines().for_each(|l| {
        if let [color, pieces] = l.split(":").collect::<Vec<&str>>()[..] {
            pieces.split(",").for_each(|p| {
                let piece = Piece::new(p);
                let player_piece = if color == "White" {
                    PlayerPiece::White(piece)
                } else {
                    PlayerPiece::Black(piece)
                };

                board.insert(player_piece);
            });
        }
    });
    // dbg!(&board);
    format!("{}", board)
}

fn main() {
    let input = "White:Ke1,Qd1,Ra1,Rh1,Bc1,Bf1,Nb1,a2,c2,d2,f2,g2,h2,a3,e4
Black:Ke8,Qd8,Ra8,Rh8,Bc8,Ng8,Nc6,a7,b7,c7,d7,e7,f7,h7,h6";
    let output = "+---+---+---+---+---+---+---+---+
|.r.|:::|.b.|:q:|.k.|:::|.n.|:r:|
+---+---+---+---+---+---+---+---+
|:p:|.p.|:p:|.p.|:p:|.p.|:::|.p.|
+---+---+---+---+---+---+---+---+
|...|:::|.n.|:::|...|:::|...|:p:|
+---+---+---+---+---+---+---+---+
|:::|...|:::|...|:::|...|:::|...|
+---+---+---+---+---+---+---+---+
|...|:::|...|:::|.P.|:::|...|:::|
+---+---+---+---+---+---+---+---+
|:P:|...|:::|...|:::|...|:::|...|
+---+---+---+---+---+---+---+---+
|.P.|:::|.P.|:P:|...|:P:|.P.|:P:|
+---+---+---+---+---+---+---+---+
|:R:|.N.|:B:|.Q.|:K:|.B.|:::|.R.|
+---+---+---+---+---+---+---+---+";
    println!("{}", solution(input));

    //     let input = "White:
    // Black:Kh5,Ke1";
    //     let output = "+---+---+---+---+---+---+---+---+
    // |...|:::|...|:::|...|:::|...|:::|
    // +---+---+---+---+---+---+---+---+
    // |:::|...|:::|...|:::|...|:::|...|
    // +---+---+---+---+---+---+---+---+
    // |...|:::|...|:::|...|:::|...|:::|
    // +---+---+---+---+---+---+---+---+
    // |:::|...|:::|...|:::|...|:::|.k.|
    // +---+---+---+---+---+---+---+---+
    // |...|:::|...|:::|...|:::|...|:::|
    // +---+---+---+---+---+---+---+---+
    // |:::|...|:::|...|:::|...|:::|...|
    // +---+---+---+---+---+---+---+---+
    // |...|:::|...|:::|...|:::|...|:::|
    // +---+---+---+---+---+---+---+---+
    // |:::|...|:::|...|:k:|...|:::|...|
    // +---+---+---+---+---+---+---+---+";
    //     println!("{}", dbg!(solution(input)) == output);
}
#+end_src

#+RESULTS:
#+begin_example
warning: unused variable: `output`
   --> src/main.rs:122:9
    |
122 |     let output = "+---+---+---+---+---+---+---+---+
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_output`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `output`
   --> src/main.rs:122:9
    |
122 |     let output = "+---+---+---+---+---+---+---+---+
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_output`
    |
    = note: `#[warn(unused_variables)]` on by default

+---+---+---+---+---+---+---+---+
|.r.|:::|.b.|:q:|.k.|:::|.n.|:r:|
+---+---+---+---+---+---+---+---+
|:p:|.p.|:p:|.p.|:p:|.p.|:::|.p.|
+---+---+---+---+---+---+---+---+
|...|:::|.n.|:::|...|:::|...|:p:|
+---+---+---+---+---+---+---+---+
|:::|...|:::|...|:::|...|:::|...|
+---+---+---+---+---+---+---+---+
|...|:::|...|:::|.P.|:::|...|:::|
+---+---+---+---+---+---+---+---+
|:P:|...|:::|...|:::|...|:::|...|
+---+---+---+---+---+---+---+---+
|.P.|:::|.P.|:P:|...|:P:|.P.|:P:|
+---+---+---+---+---+---+---+---+
|:R:|.N.|:B:|.Q.|:K:|.B.|:::|.R.|
+---+---+---+---+---+---+---+---+
#+end_example
* kattis - bijele
#+begin_src rust
fn solution(s: &str) -> String {
    let target = vec![1, 1, 2, 2, 2, 8];
    s.split_whitespace()
        .enumerate()
        .map(|(idx, v)| (target[idx] - v.parse::<i32>().unwrap()).to_string())
        .collect::<Vec<String>>()
        .join(" ")
}

fn main() {
    let i = "0 1 2 2 2 7";
    let o = "1 0 0 0 0 1";
    println!("{} == {}", solution(i), o);
    let i = "2 1 2 1 2 1";
    let o = "-1 0 0 1 0 7";
    println!("{} == {}", solution(i), o);
}
#+end_src
* kattis -
#+begin_src rust
enum Pixel {
    Point(String),
    Dot,
    Hyphen,
    Pipe,
    Plus,
}

impl From<char> for Pixel {
    fn from(c: char) -> Self {
        if c == '.' {
            Pixel::Dot
        } else {
            Pixel::Point(c.to_string())
        }
    }
}

impl std::fmt::Display for Pixel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Pixel::Dot => ".",
                Pixel::Hyphen => "-",
                Pixel::Pipe => "|",
                Pixel::Plus => "+",
                Pixel::Point(v) => v.as_str(),
            }
        )
    }
}

#[derive(Clone, Copy, Debug)]
struct Point {
    x: usize,
    y: usize,
    c: char,
}

struct Image {
    pixels: Vec<Vec<Pixel>>,
    points: Vec<Point>,
}

impl Image {
    fn parse(case: &str) -> Self {
        let mut points = case
            .lines()
            .enumerate()
            .map(|(idx, l)| {
                l.chars()
                    .enumerate()
                    .filter_map(|(idc, c)| {
                        if let Pixel::Point(p) = Pixel::from(c) {
                            return Some(Point {
                                x: idc,
                                y: idx,
                                c: p.chars().nth(0).unwrap(),
                            });
                        }
                        None
                    })
                    .collect::<Vec<Point>>()
            })
            .flatten()
            .collect::<Vec<_>>();
        points.sort_by_key(|p| p.c);
        Image {
            pixels: case
                .lines()
                .map(|l| l.chars().map(|c| Pixel::from(c)).collect::<Vec<Pixel>>())
                .collect::<Vec<_>>(),
            points: points,
        }
    }

    fn draw_horizontal(&mut self, row: usize, columns: (usize, usize)) {
        self.pixels[row][if columns.0 < columns.1 {
            columns.0..=columns.1
        } else {
            columns.1..=columns.0
        }]
        .iter_mut()
        .for_each(|v| {
            *v = match v {
                Pixel::Dot | Pixel::Hyphen => Pixel::Hyphen,
                Pixel::Pipe | Pixel::Plus => Pixel::Plus,
                Pixel::Point(v) => Pixel::Point(v.to_owned()),
            };
        });
    }

    fn draw_vertical(&mut self, column: usize, rows: (usize, usize)) {
        self.pixels[if rows.0 < rows.1 {
            rows.0..rows.1
        } else {
            rows.1..rows.0
        }]
        .iter_mut()
        .for_each(|row| {
            row[column] = match &row[column] {
                Pixel::Dot | Pixel::Pipe => Pixel::Pipe,
                Pixel::Hyphen | Pixel::Plus => Pixel::Plus,
                Pixel::Point(v) => Pixel::Point(v.to_owned()),
            }
        });
    }

    fn solve(&mut self) {
        let points = self.points.clone();
        let mut points = points.windows(2);
        while let Some([a, b]) = points.next() {
            match (a, b) {
                (a, b) if a.y == b.y => self.draw_horizontal(a.y, (a.x, b.x)),
                (a, b) if a.x == b.x => self.draw_vertical(a.x, (a.y, b.y)),
                (mut a, mut b) => {
                    if a.x > b.x || a.y > b.y {
                        std::mem::swap(&mut a, &mut b);
                    }
                    self.draw_horizontal(a.y, (a.x, b.x));
                    self.draw_vertical(b.x, (a.y, b.y));
                    self.pixels[a.y][b.x] = Pixel::Plus;
                    println!("{}", self.to_string());
                }
            };
        }
    }
}

impl std::fmt::Display for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            self.pixels
                .iter()
                .map(|r| r.iter().map(|p| p.to_string()).collect::<String>())
                .collect::<Vec<String>>()
                .join("\n")
        )
    }
}

fn solution(s: &str) -> String {
    s.split("\n\n")
        .map(Image::parse)
        .map(|mut i| {
            i.solve();
            i.to_string()
        })
        .collect::<Vec<String>>()
        .join("\n\n")
}

fn main() -> std::io::Result<()> {
    let mut i = String::new();
    std::io::Read::read_to_string(&mut std::io::stdin(), &mut i)?;
    println!("{}", solution(i.as_str()));
    let nums = vec![1, 2];
    let mut h = std::collections::HashMap::new();
    for n in nums {
        let e = h.entry(n);
        if let std::collections::hash_map::Entry::Occupied(_) = e {
            return true;
        } else {
            e.or_insert(1);
        }
    }
    let x = h.keys();
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_name() {}
}

#[test]
fn test_case_1() {
    let i = ".....0.......1
..............
..............
.....3.......2

..0.....4......
...............
...............
...............
..2.....3.....7
...............
...............
...............
..1.....5.....6

..0...............7...........8....d
......4................3............
....................................
....................................
...........a..................9.....
....................................
..1....................2............
....................................
......5...........6.................
....................................
...........b.......................c";
    let o = ".....0-------1
.............|
.............|
.....3-------2

..0.....4......
..|.....|......
..|.....|......
..|.....|......
..2-----3.....7
..|.....|.....|
..|.....|.....|
..|.....|.....|
..1.....5-----6

..0...............7-----------8....d
..|...4-----------+----3......|....|
..|...|...........|....|......|....|
..|...|...........|....|......|....|
..|...|....a------+----+------9....|
..|...|....|......|....|...........|
..1---+----+------+----2...........|
......|....|......|................|
......5----+------6................|
...........|.......................|
...........b-----------------------c";
    assert_eq!(solution(i), o);
}

#[test]
fn test_case_2() {
    let i = ".....0.......1

..1......0
2.........

..1..3...0
2.........";

    let o = ".....0-------1

..1------0
2-+.......

+-1--3---0
2-+.......";
    assert_eq!(solution(i), o);
}

#[test]
fn test_case_3() {
    let i = "1...
....
...0";

    let o = "1--+
...|
...0";
    assert_eq!(solution(i), o);
}

#[test]
fn test_case_4() {
    let i = "0...
....
...1";

    let o = "0--+
...|
...1";
    assert_eq!(solution(i), o);
}

#[test]
fn test_case_5() {
    let i = "0...
....
...1";

    let o = "0--+
...|
...1";
    assert_eq!(solution(i), o);
}

#[test]
fn test_case_6() {
    let i = "...0
....
1...";

    let o = "+--0
|...
1..,";
    assert_eq!(solution(i), o);
}

#[test]
fn test_case_7() {
    let i = "1...
....
...0";

    let o = "1--+
...|
...0";
    assert_eq!(solution(i), o);
}

#[test]
fn test_case_8() {
    let i = "...1
....
0...";

    let o = "+--1
|...
0...";
    assert_eq!(solution(i), o);
}
#+end_src

* leetcode - 122. Best Time to Buy and Sell Stock II
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii
#+begin_src rust
impl Solution {
    pub fn max_profit(prices: Vec<i32>) -> i32 {
        prices.as_slice()
              .windows(2)
              .fold(0, |acc, x| if x[0] < x[1] {x[1] - x[0] + acc} else {acc})
    }
}
#+end_src
* leetcode - 189. Rotate Array
https://leetcode.com/problems/rotate-array/
#+begin_src rust
impl Solution {
    pub fn rotate(nums: &mut Vec<i32>, k: i32) {
        nums.rotate_right(k as usize);
    }
}
#+end_src
- Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.
- Could you do it in-place with O(1) extra space?

* leetcode - 217. Contains Duplicate
https://leetcode.com/problems/contains-duplicate
[[https://leetcode.com/problems/contains-duplicate/discuss/1473303/Rust-Simple-solution-using-sorting][interesting remark:]]
#+begin_quote
Although using HashSet has a complexity of O(N), it has a very large constant factor due to the slow hashing algorithm. So in many cases, especially with smaller arrays it's faster in practice to sort the array
#+end_quote

#+begin_src rust
impl Solution {
    pub fn contains_duplicate(nums: Vec<i32>) -> bool {
        let mut h = std::collections::HashMap::new();
        for n in nums {
            let e = h.entry(n);
            if let std::collections::hash_map::Entry::Occupied(_) = e {
                return true;
            } else {
                e.or_insert(1);
            }
        }
        false
    }
}
#+end_src

#+RESULTS:
: false
* leetcode - 136. Single Number
#+begin_src rust
impl Solution {
    pub fn single_number(nums: Vec<i32>) -> i32 {
        assert_eq!(5, 0 ^ 5);
        assert_eq!(0, 5 ^ 5); // XOR'ing a number with itself yields zero
        assert_eq!(6, 10 ^ 10 ^ 6 ^ 2 ^ 8 ^ 8 ^ 2);
        assert_eq!(6, (((10 ^ 10 ^ 6) ^ 2) ^ (8 ^ 8 ^ 2))); // XOR is associative, i.e. (x^y)^x = x^(y^x) = y
        nums.iter().fold(0, |acc, x| acc ^ x)
    }
}
#+end_src
* leetcode - 350. Intersection of Two Arrays II
https://leetcode.com/problems/intersection-of-two-arrays-ii/
#+begin_src rust
/// Time Complexity:    O(max(`len1`, `len2`))
/// Space Complexiyt:   O(26) ~ O(1)
impl Solution {
    pub fn intersect(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {
        let mut h = std::collections::HashMap::new();
        for n in nums1 {
            let e = h.entry(n).or_insert((0,0));
            ,*e = (e.0 + 1, 0);
        }
        for n in nums2 {
            let e = h.entry(n).or_insert((0,0));
            ,*e = (e.0, e.1 + 1);
        }
        let mut r = vec![];
        for (k,v) in h {
            let min = std::cmp::min(v.0, v.1);
            if min > 0 {
                r.extend(vec![k; min]);
            }
        }
        r
    }
}
#+end_src
- What if the given array is already sorted? How would you optimize your algorithm?
  - i'd iterate over both arrays simultaneously, while pushing the needle in array which points to value bigger than the other array
- What if nums1's size is small compared to nums2's size? Which algorithm is better?
- What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
** COMMENT cool
- https://leetcode.com/problems/intersection-of-two-arrays-ii/discuss/1469616/Short-and-clean-Rust-solution-(n-log-n-0ms)
* leetcode - 66. Plus One
https://leetcode.com/problems/plus-one
#+begin_src rust
impl Solution {
    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {
        for n in digits.iter_mut().rev() {
            if *n == 9 {
                *n = 0;
            } else {
                *n += 1;
                return digits;
            }
        }
        digits.insert(0, 1);
        digits
    }
}
#+end_src
* leetcode - 283. Move Zeroes
https://leetcode.com/problems/move-zeroes/
#+begin_src rust
impl Solution {
    pub fn move_zeroes(nums: &mut Vec<i32>) {
        let c = nums.iter().filter(|x| *x == &0).count();
        nums.retain(|x| *x != 0);
        nums.extend(vec![0; c]);
    }
}
#+end_src
** comment cool
- using =Vec.swap()= https://leetcode.com/problems/move-zeroes/discuss/521275/Rust-Solution
* leetcode - 1. Two Sum
https://leetcode.com/problems/two-sum/
#+begin_src rust
impl Solution {
    pub fn two_sum2(mut nums: Vec<i32>, target: i32) -> Vec<i32> {
        nums.sort_unstable();
        let (mut idn, mut idr) = (0, nums.len()-1);
        let (mut a, mut b) = (0, 0);
        while a+b != target {
            a = nums[idn];
            b = nums[idr];
            if a + b > target {
                idr -= 1;
            } else if a + b < target{
                idn += 1;
            }
        }
        vec![idn as i32, idr as i32]
    }

    pub fn two_sum(mut nums: Vec<i32>, target: i32) -> Vec<i32> {
        use std::collections::HashMap;
        let mut h: HashMap<i32, i32> = HashMap::new();
        for (i,n) in nums.iter().enumerate() {
            let aim = target - n;
            match h.get(&aim) {
                Some(v) => return vec![i as i32, *v],
                None => h.insert(*n, i as i32)
            };
        }
        unreachable!()
    }
}
#+end_src
*
* leetcode - 36. Valid Sudoku
https://leetcode.com/problems/valid-sudoku/
#+begin_src rust
impl Solution {
    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {
        macro_rules! check {
            ($vector:ident) => {
                for v in $vector.as_slice().windows(2) {
                    if v[0] == v[1] && v[0] != '.' {
                        return false;
                    }
                }
            }
        }

        // check rows
        for row in &board {
            let mut row = row.clone();
            row.sort();
            check!(row);
        }

        // check cols
        for i in 0..9 {
            let mut col = vec![];
            for row in &board {
                col.push(row[i]);
            }
            col.sort();
            check!(col);
        }

        // check squares
        for chunk in board.as_slice().chunks(3) {
            for col_chunk in (0..9).collect::<Vec<usize>>().as_slice().chunks(3) {
                let mut square = vec![];
                if let [a,b,c] = col_chunk {
                    for rc in chunk {
                        square.extend(vec![rc[*a], rc[*b], rc[*c]]);
                    }
                }
                square.sort();
                check!(square);
            }
        }

        true
    }}#+end_src
** comment todo cool stuff, be sure to check it out
- https://leetcode.com/problems/valid-sudoku/discuss/1602917/rust-rust-rust
- https://leetcode.com/problems/valid-sudoku/discuss/440491/rust
- https://leetcode.com/problems/valid-sudoku/discuss/1261934/Rust-Solution-using-Three-1-D-Arrays-with-Bit-Manipulation-instead-of-HashSet
- https://leetcode.com/problems/valid-sudoku/discuss/1602917/rust-rust-rust
- https://leetcode.com/problems/valid-sudoku/discuss/1516143/Very-simple-and-elegant-rust-solution-with-just-one-loop-and-HashSets
- https://leetcode.com/problems/valid-sudoku/discuss/1583183/Rust-Solution-with-too-many-Iterators
* leetcode - 48. Rotate Image
https://leetcode.com/problems/rotate-image/
#+begin_src rust
impl Solution {
    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {
        let n = matrix.len();
        for i in 0..n/2 {
            let (t,b) = (i, n-i-1); // rows (top, bottom)
            let (l,r) = (i, n-i-1); // cols (left, right)
            for shift in 0..n-i*2-1 {
                let temp = matrix[t][l+shift];
                matrix[t][l+shift] = matrix[b-shift][l];
                matrix[b-shift][l] = matrix[b][r-shift];
                matrix[b][r-shift] = matrix[t+shift][r];
                matrix[t+shift][r] = temp;
            }
        }
    }
}#+end_src
** comment cool stuff
- [[https://leetcode.com/problems/rotate-image/discuss/627819/Rust-double-for-loops-bitwise-O(1)-space.-(0-ms-faster-than-100.)][interesting usage of =!x = -x-1=]]
- [[https://leetcode.com/problems/rotate-image/discuss/435653/rust-with-std%3A%3Amem%3A%3Aswap-in-2D-vector][using =std::mem::swap=]]

*** transpose array
:PROPERTIES:
:ID:       b39c3b48-7610-45a0-aa21-150d751c3e62
:END:
#+begin_src rust
fn main() {
    let mut v = vec![vec![1,2,3], vec![8,7,6]];
    transpose(&mut v);
    println!("{:?}", v);
    let mut v = vec![vec![1,2,3], vec![4,5,6], vec![7,8,9]];
    transpose(&mut v);
    println!("{:?}", v);
    for r in v.iter_mut() {
       r.reverse();
    }
    println!("{:?}", v);
}

fn transpose(matrix: &mut Vec<Vec<i32>>) {
    let n = matrix.len();
    for y in 0..n {
        for x in y..n {
            let tmp = matrix[x][y];
            matrix[x][y] = matrix[y][x];
            matrix[y][x] = tmp;
        }
    }
}
#+end_src

#+RESULTS:
: [[1, 8, 3], [2, 7, 6]]
: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]

[[1,2,3]
![4,5,6],
![7,8,9]];

[[1, 4, 7],
 [2, 5, 8],
 [3, 6, 9]]
*** rotate using XOR
#+begin_src rust
fn main() {
    let mut x = 5;
    x ^= 5;
    println!("{}", x);

    let mut v = vec![vec![1,2,3], vec![8,7,6]];
    rotate(&mut v);
    println!("{:?}", v);
    let mut v = vec![vec![1,2,3], vec![4,5,6], vec![7,8,9]];
    rotate(&mut v);
    println!("{:?}", v);
}

fn rotate(matrix: &mut Vec<Vec<i32>>) {
    matrix.reverse();
    for i in 0..matrix.len() {
        for j in i+1..matrix.len() {
            println!("i={} j={}",i,j);
            matrix[i][j] ^= matrix[j][i];
            matrix[j][i] = matrix[i][j] ^ matrix[j][i];
            matrix[i][j] ^= matrix[j][i];
        }
    }
}
#+end_src

#+RESULTS:
: 0e
: i=0 j=1
: [[8, 1, 6], [7, 2, 3]]
: i=0 j=1
: i=0 j=2
: i=1 j=2
: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]
* leetcode - reverse integer
#+begin_src rust
impl Solution {
    pub fn reverse(x: i32) -> i32 {
        x.signum() * x.to_string()
                      .chars()
                      .filter(|c| c.is_ascii_digit())
                      .rev()
                      .collect::<String>()
                      .parse().unwrap_or(0)
    }
}
#+end_src
* leetcode - first unique character
#+begin_src rust
use std::collections::HashMap;
#[derive(Eq, PartialEq, Hash)]
struct Thing {
    pos: usize,
    count: u32,
}
impl Thing {
    fn new(pos: usize) -> Self {
        Thing { pos, count: 0 }
    }
    fn increment(&mut self) {
        self.count += 1;
    }
}
impl Solution {
    pub fn first_uniq_char(s: String) -> i32 {
        let mut h: HashMap<char, Thing> = HashMap::new();
        s.chars()
            .enumerate()
            .for_each(|(i, c)| h.entry(c).or_insert(Thing::new(i)).increment());
        if let Some(t) = h
            .iter()
            .filter(|(k, v)| v.count == 1)
            .min_by_key(|(k, v)| v.pos)
        {
            t.1.pos as i32
        } else {
            -1
        }
    }
}
#+end_src
* leetcode - is anagram
#+begin_src rust
impl Solution {
    pub fn is_anagram(s: String, t: String) -> bool {
        const alphabet: std::ops::RangeInclusive<char> = 'a'..='z';
        let f = |s: String| {
            let mut arr = [0; 26];
            s.chars().for_each(|c| arr[alphabet.position(|i| c == i).unwrap()] += 1);
            arr
        };
        f(s) == f(t)
    }
}
#+end_src
* leetcode - group anagrams
#+begin_src rust
use std::collections::{HashMap,HashSet};

impl Solution {
    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {
        let mut h: HashMap<Vec<char>, Vec<String>> = HashMap::new();
        for s in strs {
            let mut v = s.chars().collect::<Vec<char>>();
            v.sort();
            let mut e = h.entry(v).or_insert(vec![]);
            e.push(s);
        }
        let mut r = vec![];
        for v in h.values() {
            r.push(v.to_owned());
        }
        r
    }
}
#+end_src
* leetcode - set matrix zeroes
#+begin_src rust
impl Solution {
    pub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {
        let mut cols = vec![];
        for row in matrix.iter_mut() {
            if row.contains(&0) {
                row.iter()
                    .enumerate()
                    .filter(|(i, x)| *x == &0)
                    .for_each(|(i, _)| cols.push(i));
                let r = vec![0i32; row.len()];
                let v = std::mem::replace(row, r);
            }
        }
        for row in matrix {
            for col in cols.iter() {
                row[*col] = 0;
            }
        }
    }
}
#+end_src
* leetcode - longest substring without repeating characters
** non-linear 0(n^2) time complexity
#+begin_src rust
impl Solution {
    pub fn length_of_longest_substring(s: String) -> i32 {
        let (mut maxlen, mut b) = (0, 0);
        for (i, c) in s.chars().enumerate() {
            if let Some(cp) = s[b..i].chars().rev().position(|x| c == x) {
                b = i - cp;
            }
            maxlen = std::cmp::max(maxlen, s[b..=i].len());
        }
        maxlen as i32
    }
}
#+end_src
** linear time complexity
#+begin_src rust
impl Solution {
    pub fn length_of_longest_substring(s: String) -> i32 {
        let (mut start, mut maxlen, mut map) = (0, 0, [0; 256]);
        for (end, ch) in s.chars().enumerate() {
            if let Some(v) = map.get_mut(ch as usize) {
                start = std::cmp::max(start, *v);
                *v = end + 1;
            }
            maxlen = std::cmp::max(maxlen, end + 1 - start);
        }
        maxlen as i32
    }
}
#+end_src
** other interesting approaches
- [[https://leetcode.com/explore/interview/card/top-interview-questions-medium/103/array-and-strings/779/discuss/247505/Rust-0ms-beats-100-using-VecDeque-10-lines-of-code][using VecDeque]]
* leetcode - Letter Combinations of a Phone Number
** using =itertools= crate
#+begin_src rust
use itertools::Itertools;

fn main() {}
struct Solution;
impl Solution {
    pub fn letter_combinations(digits: String) -> Vec<String> {
        let mut l = std::collections::HashMap::new();
        l.insert(2, vec!['a', 'b', 'c']);
        l.insert(3, vec!['d', 'e', 'f']);
        l.insert(4, vec!['g', 'h', 'i']);
        l.insert(5, vec!['j', 'k', 'l']);
        l.insert(6, vec!['m', 'n', 'o']);
        l.insert(7, vec!['p', 'q', 'r', 's']);
        l.insert(8, vec!['t', 'u', 'v']);
        l.insert(9, vec!['w', 'x', 'y', 'z']);

        let letters = digits
            .chars()
            .map(|c| c.to_digit(10).unwrap())
            .map(|d| l[&d].clone())
            .multi_cartesian_product()
            .map(|v| v.iter().collect::<String>())
            .collect_vec();

        println!("{:?}", letters);
        letters
    }
}
#[test]
fn test_double() {
    let s = "23".to_string();
    let x = Solution::letter_combinations(s);
    let ans = vec!["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
        .iter()
        .map(|x| x.to_string())
        .collect::<Vec<String>>();
    assert_eq!(x, ans);
}

#[test]
fn test_single() {
    let s = "2".to_string();
    let x = Solution::letter_combinations(s);
    let ans = vec!["a", "b", "c"]
        .iter()
        .map(|x| x.to_string())
        .collect::<Vec<String>>();
    assert_eq!(x, ans);
}

#[test]
fn test_name() {
    let s = "234".to_string();
    let x = Solution::letter_combinations(s);
    let ans = vec![
        "add", "ade", "adf", "aed", "aee", "aef", "afd", "afe", "aff", "bdd", "bde", "bdf", "bed",
        "bee", "bef", "bfd", "bfe", "bff", "cdd", "cde", "cdf", "ced", "cee", "cef", "cfd", "cfe",
        "cff",
    ]
    .iter()
    .map(|x| x.to_string())
    .collect::<Vec<String>>();
    assert_eq!(x, ans);
}
#+end_src
** using =flat_map=
#+begin_src rust
impl Solution {
    pub fn letter_combinations(digits: String) -> Vec<String> {
        if digits.len() == 0 { return vec![]; }
        let mut l = std::collections::HashMap::new();
        l.insert(2, vec!['a', 'b', 'c']);
        l.insert(3, vec!['d', 'e', 'f']);
        l.insert(4, vec!['g', 'h', 'i']);
        l.insert(5, vec!['j', 'k', 'l']);
        l.insert(6, vec!['m', 'n', 'o']);
        l.insert(7, vec!['p', 'q', 'r', 's']);
        l.insert(8, vec!['t', 'u', 'v']);
        l.insert(9, vec!['w', 'x', 'y', 'z']);


        digits.chars().fold(vec![String::from("")], |acc, digit| {
            acc.iter()
                .flat_map(|x| {
                    l[&digit.to_digit(10).unwrap()]
                        .iter()
                        .map(|y| format!("{}{}", x, y))
                        .collect::<Vec<String>>()
                })
                .collect()
        })

    }
}
#+end_src
* leetcode - Longest Palindromic Substring
** O(n^2) solution
#+begin_src rust
fn main() {}
struct Solution;
impl Solution {
    fn add_bogus_char(s: &str) -> String {
        s.chars().map(|x| format!("|{}", x)).collect::<String>() + "|"
    }
    fn distance_to_edge(center: usize, length: usize) -> usize {
        std::cmp::min(center, length - center)
    }
    fn is_reflected(s: &str, center: usize, radius: usize) -> bool {
        s.chars().nth(center - radius) == s.chars().nth(center + radius)
    }
    fn max_with_position<T: Ord + Copy>(v: Vec<T>) -> (T, usize) {
        let max_value = v.iter().max().unwrap().to_owned();
        let max_position = v.iter().position(|x| *x == max_value).unwrap();
        (max_value, max_position)
    }
    fn extract_string(s: &str, max: usize, pos: usize) -> String {
        s[pos - max + 1..pos + max]
            .chars()
            .filter(|c| c != &'|')
            .collect::<String>()
    }

    fn lps(s: &str) -> String {
        let s = Self::add_bogus_char(s);
        let mut radii = vec![0; s.len()];
        let mut radius = 0;
        for (center, _) in s.chars().enumerate() {
            let distance = Self::distance_to_edge(center, s.len());
            if distance > 1 {
                for r in 0..distance {
                    if Self::is_reflected(&s, center, r) {
                        radius += 1;
                    } else {
                        break;
                    }
                }
            }
            radii[center] = radius;
            radius = 0;
        }

        let (max, pos) = Self::max_with_position(radii);
        Self::extract_string(s, max, pos)
    }
}

#[test]
fn test_name() {
    let s = "abracadabba".to_string();
    let x = Solution::lps(&s);
    assert_eq!("abba", x);
}
#[test]
fn test_w() {
    let s = "aba".to_string();
    let x = Solution::lps(&s);
    assert_eq!("aba", x);
}
#[test]
fn test_nrame() {
    let s = "abc".to_string();
    let x = Solution::lps(&s);
    assert_eq!("b", x);
}
#[test]
fn test_nfame() {
    let s = "xyxfwirf".to_string();
    let x = Solution::lps(&s);
    assert_eq!("xyx", x);
}
#[test]
fn test_nfafe() {
    let s = "fuyfwrxyx".to_string();
    let x = Solution::lps(&s);
    assert_eq!("xyx", x);
}
#+end_src
** O(n) solution
#+begin_src rust
impl Solution {
    fn add_bogus_char(s: &str) -> String {
        s.chars().map(|x| format!("|{}", x)).collect::<String>() + "|"
    }
    fn distance_to_edge(center: usize, length: usize) -> usize {
        std::cmp::min(center, length - center)
    }
    fn is_reflected(s: &str, center: usize, radius: usize) -> bool {
        s.chars().nth(center - radius) == s.chars().nth(center + radius)
    }
    fn max_with_position<T: Ord + Copy>(v: Vec<T>) -> (T, usize) {
        let max_value = v.iter().max().unwrap().to_owned();
        let max_position = v.iter().position(|x| *x == max_value).unwrap();
        (max_value, max_position)
    }
    fn extract_string(s: &str, max: usize, pos: usize) -> String {
        s[pos - max + 1..pos + max]
            .chars()
            .filter(|c| c != &'|')
            .collect::<String>()
    }

    fn longest_palindrome(s: String) -> String {
        let s = Self::add_bogus_char(&s);
        let mut palindrome_radii = vec![0; s.len()];

        let mut center = 0;
        let mut radius = 0;

        while center < s.len() {
            // At the start of the loop, radius is already set to a lower-bound for the longest radius.
            // In the first iteration, radius is 0, but it can be higher.

            // Determine the longest palindrome starting at center-radius and going to center+radius

            while center as isize - (radius as isize + 1) >= 0
                && center as isize + (radius as isize + 1) < s.len() as isize
                && s.chars()
                    .nth((center as isize - (radius as isize + 1)) as usize)
                    == s.chars()
                        .nth((center as isize + (radius as isize + 1)) as usize)
            {
                radius = radius + 1;
            }

            // Save the radius of the longest palindrome in the array
            palindrome_radii[center] = radius;

            // Below, center is incremented.
            // If any precomputed values can be reused, they are.
            // Also, radius may be set to a value greater than 0

            let old_center = center;
            let old_radius = radius;
            center = center + 1;
            // radius' default value will be 0, if we reach the end of the following loop.
            radius = 0;
            while center <= old_center + old_radius {
                // Because center lies inside the old palindrome and every character inside
                // a palindrome has a "mirrored" character reflected across its center, we
                // can use the data that was precomputed for the center's mirrored point.
                let mirrored_center = old_center - (center - old_center);
                let max_mirrored_radius = old_center + old_radius - center;
                if palindrome_radii[mirrored_center] < max_mirrored_radius {
                    palindrome_radii[center] = palindrome_radii[mirrored_center];
                    center = center + 1;
                } else if palindrome_radii[mirrored_center] > max_mirrored_radius {
                    palindrome_radii[center] = max_mirrored_radius;
                    center = center + 1;
                } else {
                    // palindrome_radii[mirrored_center] = max_mirrored_radius
                    radius = max_mirrored_radius;
                    break; // exit while loop early
                }
            }
        }

        let (max, pos) = Self::max_with_position(palindrome_radii);
        Self::extract_string(&s, max, pos)
    }
}
#+end_src
* leetcode - Sum of two integers
#+begin_quote
return the sum of the two integers without using the operators + and -
#+end_quote
** to string, iterating over bits, adding bit by bit
#+begin_src rust
fn main() {}
struct Solution;
impl Solution {
    pub fn get_sum(a: i32, b: i32) -> i32 {
        let mut result = std::collections::VecDeque::new();
        let mut carry = false;
        let a = format!("{:#032b}", a);
        let b = format!("{:#032b}", b);
        let a = a.trim_start_matches("0b");
        let b = b.trim_start_matches("0b");
        for (aa, bb) in a
            .chars()
            .zip(b.chars())
            .collect::<Vec<(char, char)>>()
            .iter()
            .rev()
        {
            let v = match (carry, aa.to_digit(10).unwrap(), bb.to_digit(10).unwrap()) {
                (false, 0, 0) => 0,
                (false, 1, 1) => {
                    carry = true;
                    0
                }
                (false, 1, 0) | (false, 0, 1) => 1,
                (true, 0, 1) | (true, 1, 0) => {
                    carry = true;
                    0
                }
                (true, 1, 1) => {
                    carry = true;
                    1
                }
                (true, 0, 0) => {
                    carry = false;
                    1
                }
                _ => panic!(),
            };
            result.push_front(v);
        }
        let result = Vec::<i32>::from(result)
            .iter()
            .map(|i| i.to_string())
            .collect::<String>();
        i32::from_str_radix(&result, 2).unwrap()
    }
}

#[test]
fn test_double() {
    let x = Solution::get_sum(11, 13);
    assert_eq!(x, 11 + 13);
}
#[test]
fn test_rouble() {
    let x = Solution::get_sum(14, 13);
    assert_eq!(x, 14 + 13);
}
#[test]
fn test_roubie() {
    let x = Solution::get_sum(1, 1);
    assert_eq!(x, 2);
}
#+end_src
**
#+begin_src rust
fn bitwise_add(mut a: i32, mut b: i32) -> i32 {
    while b != 0 {
        let carry = a & b;  // carry value is calculated
        println!("a:{:#08b}\nb:{:#08b}\nc:{:#08b}\n---", a,b,carry);
        a = a ^ b;      // sum value is calculated and stored in a
        b = carry << 1; // the carry value is shifted towards left by a bit
        println!("a:{:#08b}\nb:{:#08b}\nc:{:#08b}\n", a,b,carry);
    }
    a
}

fn main() {
    // bitwise_add(11,13);
    bitwise_add(2,1);
}
#+end_src

#+RESULTS:
: a:0b000010
: b:0b000001
: c:0b000000
: ---
: a:0b000011
: b:0b000000
: c:0b000000
:

* leetcode - add two numbers
** iterative
#+begin_src rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option<Box<ListNode>>
// }
//
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -> Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl ListNode {
    fn push(self, elem: i32) -> Self {
        let mut new_node = Self::new(elem);
        new_node.next = Some(Box::new(self));
        new_node
    }
    fn extract_vals(mut ll: Option<Box<ListNode>>) -> Vec<i32> {
        let mut v = vec![];
        while let Some(x) = ll {
            v.push(x.val);
            ll = x.next;
        }
        v
    }
}
impl Solution {
    fn extract_vals(mut ll: Option<Box<ListNode>>) -> Vec<i32> {
        let mut v = vec![];
        while let Some(x) = ll {
            v.push(x.val);
            ll = x.next;
        }
        v
    }
    fn get_sum(mut v1: Vec<i32>, mut v2: Vec<i32>) -> std::collections::VecDeque<i32> {
        let mut carry = 0;
        let mut r = std::collections::VecDeque::with_capacity(100);
        let lendiff = v1.len() as isize - v2.len() as isize;
        if lendiff > 0 {
            v2.extend(vec![0; lendiff as usize]);
        } else {
            v1.extend(vec![0; lendiff.abs() as usize]);
        }
        for (a,b) in v1.iter().zip(v2.iter()) {
            let x = a + b + carry;
            r.push_front(if x >= 10 {
                carry = 1;
                x.rem_euclid(10)
            } else {
                carry = 0;
                x
            });
        }
        if carry == 1 {
            r.push_front(1);
        }
        r
    }
    pub fn add_two_numbers(mut l1: Option<Box<ListNode>>,  mut l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let n1 = ListNode::extract_vals(l1);
        let n2 = ListNode::extract_vals(l2);
        let mut digits = Self::get_sum(n1, n2);
        let init = digits.pop_front().unwrap();
        let mut node = ListNode::new(init);
        for d in digits {
            node = node.push(d);
        }
        Some(Box::new(node))
    }
}
#+end_src
** recursive (faster)
#+begin_src rust
impl Solution {
    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        match (l1, l2) {
            (None, None) => None,
            (Some(n), None) | (None, Some(n)) => Some(n),
            (Some(n1), Some(n2)) => {
                let sum = n1.val + n2.val;
                if sum < 10 {
                    Some(Box::new(ListNode {
                        val: sum,
                        next: Solution::add_two_numbers(n1.next, n2.next)
                    }))
                } else {
                    let carry = Some(Box::new(ListNode::new(1)));
                    Some(Box::new(ListNode {
                        val: sum - 10,
                        next: Solution::add_two_numbers(Solution::add_two_numbers(carry, n1.next), n2.next)
                    }))
                }
            }
        }
    }
}
#+end_src
* leetcode - two sum
#+begin_src rust
impl Solution {
    pub fn two_sum(mut nums: Vec<i32>, target: i32) -> Vec<i32> {
        while let Some(v) = nums.pop() {
            for (idx, _) in nums.iter().enumerate().filter(|(_, n)| v + **n == target) {
                return vec![idx as i32, nums.len() as i32];
            }
        }
        return vec![];
    }
}
#+end_src
** other interesting approaches
- [[https://leetcode.com/problems/two-sum/discuss/1563252/Functional-Rust][hashmap.and_then]]
- [[https://leetcode.com/problems/two-sum/discuss/1067029/Fast-(somewhat)-idiomatic-rust-solution-using-moving-pointers.-0ms-2mb][sort then peek from both ends]]
* leetcode - Two Sum II - Input Array Is Sorted
#+begin_src rust
impl Solution {
    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {
        let mut start = numbers.iter().enumerate().peekable();
        let mut end = numbers.iter().enumerate().rev().peekable();

        while let (Some(s), Some(e)) = (start.peek(), end.peek()) {
            match (*s.1 + *e.1).cmp(&target) {
                std::cmp::Ordering::Less => start.next(),
                std::cmp::Ordering::Equal => return vec![1+s.0 as i32, 1+e.0 as i32],
                std::cmp::Ordering::Greater => end.next(),
            };
        }
        vec![]
    }
}
#+end_src
* leetcode - binary search
#+begin_src rust
impl Solution {
    pub fn search(nums: Vec<i32>, target: i32) -> i32 {
        nums.binary_search(&target)
            .map_or_else(|i| -1 as i32, |i| i as i32)
    }
}
#+end_src
* interview - max of increasing then decreasing array
#+begin_src rust
fn take_max(mut a: &[u32]) -> u32 {
    loop {
        if a.len() < 3 {
            return *a.iter().max().unwrap()
        }
        let i = a.len() / 2;
        let x = a.get(i-1).unwrap();
        let y = a.get(i).unwrap();
        if x > y {
            a = &a[..i];
        } else {
            a = &a[i..];
        }
    }
}

fn take_max_r(mut a: &[u32]) -> u32 {
    if a.len() < 3 {
        return *a.iter().max().unwrap()
    }
    let i = a.len() / 2;
    let x = a.get(i-1).unwrap();
    let y = a.get(i).unwrap();
    if x > y {
        take_max_r(&a[..i])
    } else {
        take_max_r(&a[i..])
    }
}

fn main() {
    let i = [1,2,3,4,3,2];
    let o = 4;
    assert_eq!(take_max(&i),o);
    let i = [1,2,3,4];
    let o = 4;
    assert_eq!(take_max(&i),o);
    let i = [4,3,2,1];
    let o = 4;
    assert_eq!(take_max(&i),o);
    let i = [1];
    let o = 1;
    assert_eq!(take_max(&i),o);
    // let i = [];
    // let o = None;
    // assert_eq!(take_max(&i),o);
    let i = [1,2,3,4,3,2];
    let o = 4;
    assert_eq!(take_max_r(&i),o);
    let i = [1,2,3,4];
    let o = 4;
    assert_eq!(take_max_r(&i),o);
    let i = [4,3,2,1];
    let o = 4;
    assert_eq!(take_max_r(&i),o);
    let i = [1];
    let o = 1;
    assert_eq!(take_max_r(&i),o);
    // let i = [];
    // let o = None;
    // assert_eq!(take_max_r(&i),o);
}
#+end_src

#+RESULTS:
